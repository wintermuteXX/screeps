1. 	TODO
		- miner with no free source is crashing code
		- Use spawnCreep(body, name, [opts]), cancreate + create is deprecated
    	- Remote Mining (check for goals, new behavior)
		- 2 Upgrader if Dropped energy around Controller > 5000 ?
		- Scout upgrade controller - check if still exists + my (in case you unclaim controller for a reason)
        - source - define Container RoomPosition
        - miner - if idle - repair container
        - miner - if link empty + container filled -> transfer to link.
        - recalculate needed transporters
		- createCreep. Calculate Move parts dynamically (body2)
        - build queue for needed resources (id, amount, type)(bonus: implement priority (power-mineral-energy))
        - prototype check if creep has same target (so not all creeps are running to the same ressource pile)
        -- Sell + Buy at Market (check code at bottom of this file)
    	-- Scout could dismantle buildings in target room?
    	-- Harvest Power
		-- test attack behavior
		-- spawn defenders if attacked
    	-- Boost creeps
   	BUGS
	    - (bug) when controller downgrades during construction, workers can't finish behavior construction
   	TESTING
    	- (testing) Resource Queue - Mineral in Container funktioniert nicht. 
        - (testing) miner - walk to container, not source
        - (testing) build queue for pickable resources (id, amount, type)(bonus: implement priority (power-mineral-energy))
		- (testing) behavior harvest works on empty source
  	DONE
	  	- (done) Limit Upgrader Work parts in RCL 8
		- (done) behavior.harvest:11 /// return (creep.energy === creep.energyCapacity || source.energy === 0); /// TypeError: Cannot read property 'energy' of null
	    - (done) write general behavior for picking up resources. User Resource queue
        - (done) Update build creeps to always build max body.
		- (done) Separate role for upgrader in RCL 1+2+ (3?) (Activated in RCL2)
        - (done) Behavior Pickup Minerals (buggy - doesn't work)
        - (done) Behavior Harvest Minerals (needs spawn logic)
		- (done) Behavior Transport Minerals to Terminal
        - (done) (bug) Upgrade Rampart hört nicht auf wenn max erreicht ist. fix: Hardcoded value durch maxHits ersetzt.
		- (done) (bug) Fallback if no creeps in active room (Implemented but fails?) - Fix: Limit parts to 300 Energy
		- (done) (bug) Limit Tower repair - FIX: New Interval repairTower
	    - (done) When storage > 100000 energy - no more input. Fix -> maxE based on constants + rcl
		- (done) Check Scout Code
    	- (done) Upgrader Link -> Storage
    	- (done) Behavior Repair Container
    	- (done) Behavior Get_energy_container (done)
		- (done) (bug) Tower Repair + Heal (repair ready, but not activated in ControllerRoom)
		- (done) (bug) Filling Storage does not work with new checks. Why?	
    

2. Code Snippets

placeContainer();
{
    if (this.room.controller.reservation &&
        /* reserved and not mine */
        this.room.controller.reservation.username != Game.structures[_.first(Object.keys(Game.structures))].owner.username) {
        // console.log(`MINER: Unable to place container in ${this.operation.name}, hostile reserved room`);
        return;
    }
    var startingPosition = this.findMinerStorage();
    if (!startingPosition) {
        startingPosition = this.room.find(FIND_MY_SPAWNS)[0];
    }
    if (!startingPosition) {
        startingPosition = this.room.find(FIND_CONSTRUCTION_SITES, { filter: (function (s) { return s.structureType === STRUCTURE_SPAWN; }) })[0];
    }
    if (!startingPosition)
        return;
    if (this.source.pos.findInRange(FIND_CONSTRUCTION_SITES, 1).length > 0)
        return;
    var ret = PathFinder.search(this.source.pos, [{ pos: startingPosition.pos, range: 1 }], {
        maxOps: 4000,
        swampCost: 2,
        plainCost: 2,
        roomCallback: function (roomName) {
            var room = Game.rooms[roomName];
            if (!room)
                return;
            var matrix = empire.traveler.getStructureMatrix(room);
            return matrix;
        }
    });
    if (ret.incomplete || ret.path.length === 0) {
        notifier.log("path used for container placement in " + this.operation.name + " incomplete, please investigate");
    }
    var position_1 = ret.path[0];
    var testPositions = _.sortBy(this.source.pos.openAdjacentSpots(true), function (p) { return p.getRangeTo(position_1); });
    for (var _i = 0, testPositions_1 = testPositions; _i < testPositions_1.length; _i++) {
        var testPosition = testPositions_1[_i];
        var sourcesInRange = testPosition.findInRange(FIND_SOURCES, 1);
        if (sourcesInRange.length > 1) {
            continue;
        }
        console.log("MINER: placed container in " + this.operation.name);
        testPosition.createConstructionSite(STRUCTURE_CONTAINER);
        return;
    }
    console.log("MINER: Unable to place container in " + this.operation.name);
}
---------------------------------------
// This is called during global reset to set up structure memory,
// because it doesn't need to be called often.
if(!Memory.structures) {
	console.log('[Memory] Initializing structure memory');
	Memory.structures = {}; 
}

// Adds structure memory to OwnedStructure things.
// Easier to reason about garbage collection in this implementation. 
Object.defineProperty(OwnedStructure.prototype, "memory", {
    get: function () {      
		if(!Memory.structures[this.id])
			Memory.structures[this.id] = {};
		return Memory.structures[this.id];
    },
	set: function(v) {
		return _.set(Memory, 'structures.' + this.id, v);
	},
	configurable: true,
	enumerable: false
});

// Call this periodically to garbage collect structure memory
// (I find once every 10k ticks is fine)
global.GCStructureMemory = function() {
   for (var id in Memory.structures )
			if(!Game.structures[id]) {
				console.log("Garbage collecting structure " + id + ', ' + JSON.stringify(Memory.structures[id]));
				delete Memory.structures[id];
			}
}
--------------------------------------------
Stick on global with `global.Log = require('Log');` and enjoy
/**
 * Log.js
 *
 * ES6 log class for logging screeps messages with color, where it makes sense.
 * @todo: abbr tag '<abbr title="World Health Organization">WHO</abbr>'
 * @todo: log groups / log levels?
 */
"use strict";

class Log {
	constructor() {
		throw new Error("Log is a static class");
	}

	static debug(msg, tag) {
		this.log(Log.LEVEL_DEBUG, msg, tag);
	}

	/** */
	static info(msg, tag) {
		this.log(Log.LEVEL_INFO, msg, tag);
	}

	/** */
	static warn(msg, tag) {
		this.log(Log.LEVEL_WARN, msg, tag);
	}

	/** */
	static error(msg, tag) {
		this.log(Log.LEVEL_ERROR, msg, tag);
	}

	/** */
	static success(msg, tag) {
		this.log(Log.LEVEL_SUCCESS, msg, tag);
	}

	/** */
	static log(level = Log.LEVEL_DEBUG, msg, tag) {
		var color = Log.color[level];
		if (tag && this.getLogLevel(tag) > level)
			return;
		this.toConsole(msg, color, tag);
	}

	/**
	 * HTML table in console
	 * ex: Log.table(['a','b'], [[1,2],[3,4]])
	 */
	static table(headers, rows) {

		let msg = '<table>';
		_.each(headers, h => msg += '<th width="50px">' + h + '</th>');
		_.each(rows, row => msg += '<tr>' + _.map(row, el => (`<th>${el}</th>`)) + '</tr>');
		msg += '</table>';
		// console.log(msg);
		return msg;
	}

	/** */
	static notify(msg, group = 0, color = 'red') {
		this.toConsole(msg, color);
		Game.notify(msg, group);
	/** */
	}

		if (!Memory.logging)
	static getLogLevel(tag) {
			Memory.logging = {};
		if (Memory.logging[tag] == null)
			return Log.LEVEL_WARN;
		return Memory.logging[tag];
	}

	/** */
	static toConsole(msg, color, tag) {
		if (tag)
			console.log(`<font color=${color}>[${tag}] ${msg}</font>`);
		else
			console.log(`<font color=${color}>${msg}</font>`);
	}

	/** */
	static progress(v, m) {
		return `<progress value="${v}" max="${m}"/>`;
	}

}

/** Log levels */
Log.LEVEL_DEBUG = 0;
Log.LEVEL_INFO = 1;
Log.LEVEL_WARN = 2;
Log.LEVEL_ERROR = 3;
Log.LEVEL_SUCCESS = 4;

/** Log colors */
Log.color = {
	[Log.LEVEL_DEBUG]: 'yellow',
	[Log.LEVEL_INFO]: 'cyan',
	[Log.LEVEL_WARN]: 'orange',
	[Log.LEVEL_ERROR]: 'red',
	[Log.LEVEL_SUCCESS]: 'green'
};

Object.freeze(Log);
Object.freeze(Log.color);

module.exports = Log;
----------------------------------------------
/** first we put the function in global */
global.defineCachedGetter = function (proto, propertyName, fn) {
	Object.defineProperty(proto, propertyName, {
		get: function() { 
			if(this === proto || this == undefined)
				return;
			let result = fn.call(this,this);
			Object.defineProperty(this, propertyName, {
				value: result,
				configurable: true,
				enumerable: false
			});
			return result;
		},
		configurable: true,
		enumerable: false
	});
} 

/** Then we define some properties! */
defineCachedGetter(Creep.prototype, 'carryTotal', c => _.sum(c.carry));
defineCachedGetter(Creep.prototype, 'carryCapacityAvailable', c => c.carryCapacity - c.carryTotal);
----------------------------------------------
if (_.sum(creep.carry)) creep.transfer(target, _.last(Object.keys(creep.carry)))
----------------------------------------------
global.encodeCoordinate = function(thePos) {
    return String.fromCodePoint(thePos.x | (thePos.y << 6));
}

global.decodeCoordinate = function(theString, theIndex) {
    var val = theString.charCodeAt(theIndex);
    var x = (val & 0x3F);
    var y = ((val >> 6) & 0x3F);
    return {
        x: x,
        y: y
    };
}
----------------------------------------
{"name":"textExport","shard":"shard0","rcl":"8","buildings":{"powerSpawn":{"pos":[{"x":22,"y":9}]},"observer":{"pos":[{"x":23,"y":9}]},"tower":{"pos":[{"x":21,"y":10},{"x":23,"y":10},{"x":24,"y":11}]},"terminal":{"pos":[{"x":24,"y":10}]},"nuker":{"pos":[{"x":21,"y":11}]},"link":{"pos":[{"x":22,"y":11}]},"storage":{"pos":[{"x":22,"y":12}]},"spawn":{"pos":[{"x":23,"y":12}]}}}
----------------------------------------
global.UNIT_COST = (body) => _.sum(body, p => BODYPART_COST[p]);
global.UNIT_COST = function (body) { return _.sum(body, function (p) { return BODYPART_COST[p]; }); };
----------------------------------------
static exitPlanner(roomName, opts={}) {
		opts = _.defaults(opts, {
			visualize: true,
			commit: false,
		});
		var cm = new PathFinder.CostMatrix;
		var room = Game.rooms[roomName];
		// var visual = room.visual;
		var visual = new RoomVisual(roomName);
		if(room) {
			if(!opts.origin)
				opts.origin = _.create(RoomPosition.prototype, room.memory.origin);
			if(!opts.origin) {
				Log.warn('No origin');
				return;
			}
			var exits = room.find(FIND_EXIT).map(e => ({pos: e, range: 0}));
			room.find(FIND_STRUCTURES).forEach(({pos,structureType}) => {
				if(structureType === STRUCTURE_RAMPART || OBSTACLE_OBJECT_TYPES.includes(structureType))
					cm.set(pos.x,pos.y,255);
			});
		} else {
			console.log('No room object');
		}
		while(true) {
			var {path,incomplete} = PathFinder.search(opts.origin, exits, {roomCallback: () => cm, maxRooms: 1});
			if(incomplete)
				break;
			console.log(JSON.stringify(path));
			var pos = path[path.length-3];
			cm.set(pos.x,pos.y,255);
			var wallOrRampart = (pos.x + pos.y) % 2;
			if(opts.commit){
				var type =  (wallOrRampart?STRUCTURE_WALL:STRUCTURE_RAMPART);
				if(pos.hasStructure(type))
					continue;
				room.addToBuildQueue(pos,type);
			}
			if(opts.visualize) {
				visual.poly(path);
				// visual.circle(pos, {fill:(wallOrRampart?'black':'green'), opacity: 0.75});
				visual.circle(pos, {fill:'red', opacity: 0.75});
			}
		}
	}
----------------------------------------------------
class Pos {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
}
Room.prototype.printRoomCosts = function(matrix, proportional = false,  aroundPos = false) {
	let x = 0, y = 0, maxCost = 5, val, line, cost, redHex, greenHex, color;
	let start = new Pos(Math.max(aroundPos && aroundPos.x - 3, 0) || 0,
					  Math.max(aroundPos && aroundPos.y - 3, 0) || 0);
	let end = new Pos(Math.min(aroundPos && aroundPos.x + 3, 49) || 49,
					  Math.min(aroundPos && aroundPos.y + 3, 49) || 49);
	console.log("costs:");
	
	if (proportional) {
	    let xP, yP
	    for (xP = start.x; xP <= end.x; xP++) {
	        for (yP = start.y; yP <= end.y; yP++) {
	            cost = matrix.get(xP, yP);
	            if (cost < 250 && cost > maxCost) {
	                maxCost = cost;
	            }
	        }
	    }
	    console.log(maxCost);
	}
	
	for (y = start.y; y <= end.y; y++) {
		line = '';
		for (x = start.x; x <= end.x; x++) {
		    val = Math.min(matrix.get(x, y) + 1, maxCost) * Math.floor(256 / maxCost);
		    redHex = (val).toString(16);
		    greenHex = (256 - val).toString(16);
		    color = ( redHex[1] ? redHex : '0' + (redHex[0] || '0') )+
		            (greenHex[1] ? greenHex : '0' + (greenHex[0] || '0') ) +
		            '00';
			line += '<a style="color: #' + color + '">███</a>';
		}
		console.log(line);
	}
}
----------------------------------------
	const structureTimeToSaveFor = 13;
	Room.prototype.getStructures =
    function (structureType, filter) {
    if (!global[this.name]) global[this.name] = {};
        if (!global[this.name].structures || Game.time-global[this.name].structures.lc > structureTimeToSaveFor) {
            global[this.name].structures = {lc: Game.time};

            var grouped = _.groupBy(this.find(FIND_STRUCTURES), (s) => s.structureType);
            var mappedGroup = {};

            for (let group in grouped) mappedGroup[group] = _.map(grouped[group], (s) => {return s ? s.id : null});

            global[this.name].structures.structures = mappedGroup;
        }

        var needed = global[this.name].structures.structures[structureType].map(Game.getObjectById).filter(obj => obj !== null);
        return filter ? _.filter(needed, filter) : needed;
    };
----------------------------------------------
	creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {filter{resourceType:RESOURCE_POWER});
----------------------------------------------
	doStats: {
        run: function () {
            Memory.stats = {
                tick: Game.time,
                cpu: _.cloneDeep(Game.cpu),
                gcl: Game.gcl,
                constructionSites: _.size(Game.constructionSites),
                tokens: Game.resources.token,

                memory: {
                    used: RawMemory.get().length
                },

                market: {
                    credits: Game.market.credits,
                    num_orders: Game.market.orders ? Object.keys(Game.market.orders).length : 0,
                }

            }
        }
    }
-----------------------------------------------
	function mayReserveController(theController) {
    if (theController.owner) {
        return false;
    }
    if (!theController.reservation) {
        return true;
    }
    if (theController.reservation.username != 'Dissi') {
        return false;
    }
    if (theController.reservation.ticksToEnd < 2500) {
        return true;
    }
    return false;
}
-------------------------------------
Memory.config = Memory.config || {}`;
----------------------------------------
global.spiralOut = function(n){
    let m=n+1;
    let result = [];
    for (let i=0; i<=49; i++ ){
        if (i % 2 === 0 || m > 49){
            result[i]=n;
            n--;
            continue;
        }
        result[i]=m;
        m++;
    }
    return result;
},
---------------------------------------
    _.invoke(Game.constructionSites, 'remove')
------------------------------------------
    Object.defineProperty(Source.prototype, "usableFields", {
  get: function (): number {
    let ret = 0;
    if (!this.memory.usableFields) {
      ret = 9 - _.countBy(this.lookForNear(LOOK_TERRAIN, true), 'terrain')['wall'];
      this.memory.usableFields = ret;
    } else {
      ret = this.memory.usableFields;
    }
    return ret;
  },
  configurable: true,
});
------------------------------------------
