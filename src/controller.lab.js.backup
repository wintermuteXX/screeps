const CONSTANTS = require("./config.constants");
const Log = require("./lib.log");

function ControllerLab(rc) {
    this.room = rc;
    this.labs = rc.room.labs;
}
// LabStatus: empty, fill, produce

/**
 * Helper function to safely get mineral amount from a lab
 * @param {StructureLab} lab - The lab to check
 * @returns {number} The amount of mineral (0 if none or error)
 */
ControllerLab.prototype._getMineralAmount = function (lab) {
    if (!lab || !lab.getFirstMineral) {
        return 0;
    }
    const mineral = lab.getFirstMineral();
    return mineral && mineral.amount ? mineral.amount : 0;
};

/**
 * Helper function to check if a lab is empty (no minerals)
 * @param {StructureLab} lab - The lab to check
 * @returns {boolean} True if lab is empty
 */
ControllerLab.prototype._isLabEmpty = function (lab) {
    if (!lab || !lab.memory) {
        return false;
    }
    return lab.memory.status === "empty" && this._getMineralAmount(lab) === 0;
};

/**
 * Helper function to check if all three labs are empty
 * @param {any} labA - First lab
 * @param {any} labB - Second lab
 * @param {StructureLab} theLab - Third lab (result lab)
 * @returns {boolean} True if all labs are empty
 */
ControllerLab.prototype._areAllLabsEmpty = function (labA, labB, theLab) {
    // @ts-ignore - labA and labB are StructureLab objects but TypeScript doesn't know
    return this._isLabEmpty(labA) && this._isLabEmpty(labB) && this._isLabEmpty(theLab);
};

/**
 * Helper function to check if a lab is filled with its resource
 * @param {any} lab - The lab to check
 * @returns {boolean} True if lab is filled
 */
ControllerLab.prototype._isLabFilled = function (lab) {
    // @ts-ignore - lab is StructureLab but TypeScript doesn't know
    if (!lab || !lab.memory || !lab.memory.status || !lab.memory.resource) {
        return false;
    }
    // @ts-ignore - lab is StructureLab but TypeScript doesn't know
    return lab.memory.status === "fill" && lab.store.getFreeCapacity(lab.memory.resource) === 0;
};

/**
 * Helper function to reset all lab memory (used when labs are out of range or error occurs)
 * @param {StructureLab} labA - First lab
 * @param {StructureLab} labB - Second lab
 * @param {StructureLab} theLab - Third lab (result lab)
 */
ControllerLab.prototype._resetLabMemory = function (labA, labB, theLab) {
    if (labA && labA.memory) {
        delete labA.memory.status;
        delete labA.memory.resource;
        delete labA.memory.usedBy;
    }
    if (labB && labB.memory) {
        delete labB.memory.status;
        delete labB.memory.resource;
        delete labB.memory.usedBy;
    }
    if (theLab && theLab.memory) {
        delete theLab.memory.status;
        delete theLab.memory.resource;
        delete theLab.memory.partnerA;
        delete theLab.memory.partnerB;
    }
};

/**
 * Helper function to check if three labs are in range of each other
 * @param {StructureLab} lab1 - First lab
 * @param {StructureLab} lab2 - Second lab
 * @param {StructureLab} lab3 - Third lab
 * @returns {boolean} True if all labs are in range
 */
ControllerLab.prototype._areLabsInRange = function (lab1, lab2, lab3) {
    if (!lab1 || !lab2 || !lab3) {
        return false;
    }
    return lab1.pos.inRangeTo(lab2.pos, CONSTANTS.LAB.RANGE) && 
           lab1.pos.inRangeTo(lab3.pos, CONSTANTS.LAB.RANGE);
};

/**
 * Helper function to assign lab partners in memory
 * @param {StructureLab} labA - First lab (resource A)
 * @param {StructureLab} labB - Second lab (resource B)
 * @param {StructureLab} labResult - Third lab (result lab)
 */
ControllerLab.prototype._assignLabPartners = function (labA, labB, labResult) {
    if (!labA || !labB || !labResult) {
        return;
    }

    if (!labA.memory) labA.memory = {};
    if (!labB.memory) labB.memory = {};
    if (!labResult.memory) labResult.memory = {};

    labA.memory.status = "empty";
    labB.memory.status = "empty";
    labResult.memory.status = "empty";
    labA.memory.usedBy = labResult.id;
    labB.memory.usedBy = labResult.id;
    labResult.memory.partnerA = labA.id;
    labResult.memory.partnerB = labB.id;
};

ControllerLab.prototype.findLabPartner = function () {
    var noStatusLabs = [];

    // Find all labs without status
    for (let i in this.labs) {
        let theLab = this.labs[i];
        if (theLab && (!theLab.memory || theLab.memory.status === undefined || theLab.memory.status === null)) {
            noStatusLabs.push(theLab);
        }
    }

    // You need at least 3 labs without status to find a partner
    if (noStatusLabs.length < CONSTANTS.ROOM.SOURCE_COUNT_CORE) {
        return;
    }

    noStatusLabs = _.shuffle(noStatusLabs);
    // Remove array items if array can not be divided by 3
    noStatusLabs.length = noStatusLabs.length - (noStatusLabs.length % 3);

    Log.debug(`calculate status for ${noStatusLabs.length} labs`, "findLabPartner");

    // Check if all lab groups are in range
    var allInRange = true;
    for (let i = 0; i < noStatusLabs.length; i += 3) {
        if (!this._areLabsInRange(noStatusLabs[i], noStatusLabs[i + 1], noStatusLabs[i + 2])) {
            allInRange = false;
            break;
        }
        Log.debug(`${noStatusLabs[i].id} is in Range to ${noStatusLabs[i + 1].id} and ${noStatusLabs[i + 2].id}`, "findLabPartner");
    }

    // Set status + labpartner in memory if all are in range
    if (allInRange) {
        Log.success(`Finding labpartners was successfull`, "findLabPartner");
        for (let j = 0; j < noStatusLabs.length; j += 3) {
            this._assignLabPartners(noStatusLabs[j], noStatusLabs[j + 1], noStatusLabs[j + 2]);
        }
    }
};

ControllerLab.prototype.checkStatus = function () {
    for (let i in this.labs) {
        let theLab = this.labs[i];
        if (!theLab || !theLab.memory || !theLab.memory.partnerA || !theLab.memory.partnerB) {
            continue;
        }

        // @ts-ignore - Game.getObjectById returns StructureLab | null
        let labA = Game.getObjectById(theLab.memory.partnerA);
        // @ts-ignore - Game.getObjectById returns StructureLab | null
        let labB = Game.getObjectById(theLab.memory.partnerB);

        // Validate that both partner labs exist
        if (!labA || !labB) {
            Log.warn(`${theLab.room.name} Partner labs not found for ${theLab.id}, resetting memory`, "checkStatus");
            // @ts-ignore - labA and labB may be null but function handles it
            this._resetLabMemory(labA, labB, theLab);
            continue;
        }

        // Empty -> Fill
        // @ts-ignore - labA and labB are StructureLab objects from Game.getObjectById
        if (this._areAllLabsEmpty(labA, labB, theLab)) {
            let reaction = this.room.getFirstPossibleLabReaction();
            if (reaction) {
                Log.success(`${theLab.room.name} will fill ${labA.id} with ${global.resourceImg(reaction["resourceA"])} and ${labB.id} with ${global.resourceImg(reaction["resourceB"])} to get ${global.resourceImg(reaction["result"])}`, "checkStatus");
                // @ts-ignore - labA and labB have memory property
                labA.memory.status = "fill";
                // @ts-ignore - labA and labB have memory property
                labA.memory.resource = reaction["resourceA"];
                // @ts-ignore - labA and labB have memory property
                labB.memory.status = "fill";
                // @ts-ignore - labA and labB have memory property
                labB.memory.resource = reaction["resourceB"];
                theLab.memory.status = "fill";
                theLab.memory.resource = reaction["result"];
            }
        }

        // Fill -> Produce
        // @ts-ignore - labA and labB are StructureLab objects from Game.getObjectById
        if (this._isLabFilled(labA) && this._isLabFilled(labB)) {
            Log.success(`${theLab.room.name} will produce ${global.resourceImg(theLab.memory.resource)} in labs`, "checkStatus");
            // @ts-ignore - labA and labB have memory property
            labA.memory.status = "produce";
            // @ts-ignore - labA and labB have memory property
            labB.memory.status = "produce";
            theLab.memory.status = "produce";
        }
    }
}


ControllerLab.prototype.produce = function () {
    for (let i in this.labs) {
        let theLab = this.labs[i];
        if (!theLab || !theLab.memory || theLab.memory.status !== "produce" || !theLab.memory.partnerA || !theLab.memory.partnerB) {
            continue;
        }

        // Check if it's time to run the reaction
        if (!REACTION_TIME || !REACTION_TIME[theLab.memory.resource] || (Game.time % REACTION_TIME[theLab.memory.resource] !== 0)) {
            continue;
        }

        // @ts-ignore - Game.getObjectById returns StructureLab | null
        let labA = Game.getObjectById(theLab.memory.partnerA);
        // @ts-ignore - Game.getObjectById returns StructureLab | null
        let labB = Game.getObjectById(theLab.memory.partnerB);

        // Validate that both partner labs exist
        if (!labA || !labB) {
            Log.warn(`${theLab.room.name} Partner labs not found for ${theLab.id}`, "lab produce");
            // @ts-ignore - labA and labB may be null but function handles it
            this._resetLabMemory(labA, labB, theLab);
            continue;
        }

        // @ts-ignore - labA and labB are StructureLab objects from Game.getObjectById
        let result = theLab.runReaction(labA, labB);
        switch (result) {
            case OK:
                break;
            case ERR_FULL:
            case ERR_INVALID_ARGS:
            case ERR_NOT_ENOUGH_RESOURCES:
                Log.success(`${theLab.room.name} Resources exhausted. Set labs status to empty. ${theLab.id}`, "lab produce");
                // @ts-ignore - labA and labB have memory property
                if (labA && labA.memory) labA.memory.status = "empty";
                // @ts-ignore - labA and labB have memory property
                if (labB && labB.memory) labB.memory.status = "empty";
                if (theLab.memory) theLab.memory.status = "empty";
                break;
            case ERR_NOT_IN_RANGE:
                // @ts-ignore - labA and labB are StructureLab objects from Game.getObjectById
                this._resetLabMemory(labA, labB, theLab);
                Log.warn(`${theLab.room.name} Problem with labs ${theLab.id}: reset all memory`, "lab produce");
                break;
            default:
                Log.warn(`${theLab.room.name} Unknown result from ${theLab.id}: ${global.getErrorString(result)}`, "lab produce");
        }
    }
}

module.exports = ControllerLab;